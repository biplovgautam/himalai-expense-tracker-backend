import json
import re
import aiohttp
from typing import Dict, Optional
from fastapi import HTTPException, status
from ..core.config import settings
from fastapi import HTTPException, status
from app.services.groq_service import GroqService

# This system prompt is carefully crafted for source detection
SYSTEM_PROMPT = """You are a financial data analysis expert. Your job is to determine the *source* of CSV transaction data files extracted from banks or financial platforms in Nepal. 

You will receive a raw CSV preview as text. Based on its structure (column headers, formatting, terminology), identify which platform the data most likely belongs to.

Common sources include (but are not limited to):
- Khalti
- eSewa
- Global IME Bank

You should identify patterns like:
- Transaction formats
- Common field names (e.g., Dr./Cr., Reference Code)
- Keywords (e.g., Fonepay, Statement Report, MOS:NTC)
- Column styles and header naming

Respond ONLY with a valid JSON in the following format:
```json
{"source": "<detected source>"}
```
Do not add any explanation or additional data. If uncertain, guess the **most likely** source.

---

Examples:

---

Example 1: **Khalti**
```
Transaction ID,Transaction Type,Transaction State,Transaction Date,Transaction Time,Service,Description,From,To,Purpose,Remarks,Reference,Amount(-) Rs,Amount(+) Rs,Balance
U94yr4RKnbnJfpdk5u6GSY,Scan and Pay,Completed,2025-04-07,18:06:40,,Scan and Transfer of Rs 500.0 to Fonepay .,Ukran Tandukar (9847344775),Fonepay ,Personal use,ttt,,500,,0
```
→
```json
{"source": "Khalti"}
```

---

Example 2: **eSewa**
```
Statement Report,Unnamed: 1,Unnamed: 2,Unnamed: 3,Unnamed: 4
From Date,Wed Mar 12 00:00:00 NPT 2025
Generated by,9819492581
Reference Code,Date Time,Description,Dr.,Cr.,Status,Balance (NPR),Channel
0VOJMBI,2025-04-11 10:15:13.0,Fund Transferred to Prithivi Rawal,30.0,0.0,COMPLETE,290.14,App
```
→
```json
{"source": "eSewa"}
```

---

Example 3: **Global IME Bank**
```
Electronic,Account,Statement,From,01-04-2025,To,12-04-2025
Account,Name,BIPLOV,GAUTAM,Opening,Balance,"1,370.24"
Account,Number,32207010040691,Closing,Balance,"5,005.72"
Account,Currency,NPR,Accrued,Interest,11.22
TXN,Date,Value,Date,Description,Remarks,Withdraw,Deposit,Balance
2025-04-12,2025-04-12,MOS:NTC,QCD9V9JN8NO:97,10.00,-,"5,005.72"
2025-04-11,2025-04-11,ASBA,CHARGE,PURE,5.00,-,"5,015.72"
```
→
```json
{"source": "Global IME"}
```"""

async def detect_source(csv_data: str) -> Dict[str, str]:
    """
    Detect the source of financial data using Grok LLM API.
    
    Args:
        csv_data: Raw CSV data as string
        
    Returns:
        Dict containing the detected source
        
    Raises:
        HTTPException: If API call fails or response parsing error occurs
    """
    # Limit CSV data size to avoid token limits
    max_csv_length = 5000
    limited_csv = csv_data[:max_csv_length]
    
    # Create user prompt with the CSV data
    user_prompt = f"""Now, detect the source from the following CSV:
```
{limited_csv}
```"""
    
    try:
        # Make API call to Grok
        async with aiohttp.ClientSession() as session:
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {settings.GROK_API_KEY}"
            }
            
            payload = {
                "messages": [
                    {"role": "system", "content": SYSTEM_PROMPT},
                    {"role": "user", "content": user_prompt}
                ],
                "temperature": 0.1,  # Low temperature for deterministic responses
                "max_tokens": 100    # Short response limit
            }
            
            api_url = settings.GROK_API_ENDPOINT
            async with session.post(api_url, json=payload, headers=headers) as response:
                if response.status != 200:
                    error_text = await response.text()
                    raise HTTPException(
                        status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
                        detail=f"LLM API error: {response.status} - {error_text}"
                    )
                
                result = await response.json()
                llm_response = result["choices"][0]["message"]["content"]
                
                # Extract JSON object using regex
                json_match = re.search(r'\{[\s\S]*\}', llm_response)
                if not json_match:
                    raise HTTPException(
                        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                        detail="Failed to extract JSON response from LLM"
                    )
                
                json_str = json_match.group(0)
                try:
                    parsed_response = json.loads(json_str)
                    return parsed_response
                except json.JSONDecodeError:
                    raise HTTPException(
                        status_code=status.HTTP_422_UNPROCESSABLE_ENTITY,
                        detail="Failed to parse JSON from LLM response"
                    )
                
    except aiohttp.ClientError as e:
        raise HTTPException(
            status_code=status.HTTP_503_SERVICE_UNAVAILABLE,
            detail=f"Failed to connect to LLM API: {str(e)}"
        )
    except Exception as e:
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail=f"Source detection error: {str(e)}"
        )
    

    